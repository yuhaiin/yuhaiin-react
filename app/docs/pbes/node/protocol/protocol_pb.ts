// @generated by protoc-gen-es v1.9.0 with parameter "target=ts,js_import_style=legacy_commonjs"
// @generated from file node/protocol/protocol.proto (package yuhaiin.protocol, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message yuhaiin.protocol.protocol
 */
export class protocol extends Message<protocol> {
  /**
   * @generated from oneof yuhaiin.protocol.protocol.protocol
   */
  protocol: {
    /**
     * @generated from field: yuhaiin.protocol.shadowsocks shadowsocks = 1;
     */
    value: shadowsocks;
    case: "shadowsocks";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.shadowsocksr shadowsocksr = 2;
     */
    value: shadowsocksr;
    case: "shadowsocksr";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.vmess vmess = 3;
     */
    value: vmess;
    case: "vmess";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.websocket websocket = 4;
     */
    value: websocket;
    case: "websocket";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.quic quic = 5;
     */
    value: quic;
    case: "quic";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.obfs_http obfs_http = 6 [json_name = "obfs_http"];
     */
    value: obfs_http;
    case: "obfsHttp";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.trojan trojan = 7;
     */
    value: trojan;
    case: "trojan";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.simple simple = 8;
     */
    value: simple;
    case: "simple";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.none none = 9;
     */
    value: none;
    case: "none";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.socks5 socks5 = 10;
     */
    value: socks5;
    case: "socks5";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.http http = 11;
     */
    value: http;
    case: "http";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.direct direct = 12;
     */
    value: direct;
    case: "direct";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.reject reject = 13;
     */
    value: reject;
    case: "reject";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.yuubinsya yuubinsya = 14;
     */
    value: yuubinsya;
    case: "yuubinsya";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.grpc grpc = 15;
     */
    value: grpc;
    case: "grpc";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.http2 http2 = 16;
     */
    value: http2;
    case: "http2";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.reality reality = 17;
     */
    value: reality;
    case: "reality";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.tls_config tls = 18;
     */
    value: tls_config;
    case: "tls";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.wireguard wireguard = 19;
     */
    value: wireguard;
    case: "wireguard";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.mux mux = 20;
     */
    value: mux;
    case: "mux";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.drop drop = 21;
     */
    value: drop;
    case: "drop";
  } | {
    /**
     * @generated from field: yuhaiin.protocol.vless vless = 22;
     */
    value: vless;
    case: "vless";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<protocol>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.protocol";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "shadowsocks", kind: "message", T: shadowsocks, oneof: "protocol" },
    { no: 2, name: "shadowsocksr", kind: "message", T: shadowsocksr, oneof: "protocol" },
    { no: 3, name: "vmess", kind: "message", T: vmess, oneof: "protocol" },
    { no: 4, name: "websocket", kind: "message", T: websocket, oneof: "protocol" },
    { no: 5, name: "quic", kind: "message", T: quic, oneof: "protocol" },
    { no: 6, name: "obfs_http", jsonName: "obfs_http", kind: "message", T: obfs_http, oneof: "protocol" },
    { no: 7, name: "trojan", kind: "message", T: trojan, oneof: "protocol" },
    { no: 8, name: "simple", kind: "message", T: simple, oneof: "protocol" },
    { no: 9, name: "none", kind: "message", T: none, oneof: "protocol" },
    { no: 10, name: "socks5", kind: "message", T: socks5, oneof: "protocol" },
    { no: 11, name: "http", kind: "message", T: http, oneof: "protocol" },
    { no: 12, name: "direct", kind: "message", T: direct, oneof: "protocol" },
    { no: 13, name: "reject", kind: "message", T: reject, oneof: "protocol" },
    { no: 14, name: "yuubinsya", kind: "message", T: yuubinsya, oneof: "protocol" },
    { no: 15, name: "grpc", kind: "message", T: grpc, oneof: "protocol" },
    { no: 16, name: "http2", kind: "message", T: http2, oneof: "protocol" },
    { no: 17, name: "reality", kind: "message", T: reality, oneof: "protocol" },
    { no: 18, name: "tls", kind: "message", T: tls_config, oneof: "protocol" },
    { no: 19, name: "wireguard", kind: "message", T: wireguard, oneof: "protocol" },
    { no: 20, name: "mux", kind: "message", T: mux, oneof: "protocol" },
    { no: 21, name: "drop", kind: "message", T: drop, oneof: "protocol" },
    { no: 22, name: "vless", kind: "message", T: vless, oneof: "protocol" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): protocol {
    return new protocol().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): protocol {
    return new protocol().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): protocol {
    return new protocol().fromJsonString(jsonString, options);
  }

  static equals(a: protocol | PlainMessage<protocol> | undefined, b: protocol | PlainMessage<protocol> | undefined): boolean {
    return proto3.util.equals(protocol, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.socks5
 */
export class socks5 extends Message<socks5> {
  /**
   * eg: 127.0.0.1
   *
   * @generated from field: string hostname = 3;
   */
  hostname = "";

  /**
   * @generated from field: string user = 1;
   */
  user = "";

  /**
   * TODO: add override hostname options
   *
   * @generated from field: string password = 2;
   */
  password = "";

  constructor(data?: PartialMessage<socks5>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.socks5";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): socks5 {
    return new socks5().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): socks5 {
    return new socks5().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): socks5 {
    return new socks5().fromJsonString(jsonString, options);
  }

  static equals(a: socks5 | PlainMessage<socks5> | undefined, b: socks5 | PlainMessage<socks5> | undefined): boolean {
    return proto3.util.equals(socks5, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.http
 */
export class http extends Message<http> {
  /**
   * @generated from field: string user = 1;
   */
  user = "";

  /**
   * @generated from field: string password = 2;
   */
  password = "";

  constructor(data?: PartialMessage<http>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.http";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): http {
    return new http().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): http {
    return new http().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): http {
    return new http().fromJsonString(jsonString, options);
  }

  static equals(a: http | PlainMessage<http> | undefined, b: http | PlainMessage<http> | undefined): boolean {
    return proto3.util.equals(http, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.shadowsocks
 */
export class shadowsocks extends Message<shadowsocks> {
  /**
   * @generated from field: string method = 1;
   */
  method = "";

  /**
   * @generated from field: string password = 2;
   */
  password = "";

  constructor(data?: PartialMessage<shadowsocks>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.shadowsocks";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): shadowsocks {
    return new shadowsocks().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): shadowsocks {
    return new shadowsocks().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): shadowsocks {
    return new shadowsocks().fromJsonString(jsonString, options);
  }

  static equals(a: shadowsocks | PlainMessage<shadowsocks> | undefined, b: shadowsocks | PlainMessage<shadowsocks> | undefined): boolean {
    return proto3.util.equals(shadowsocks, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.shadowsocksr
 */
export class shadowsocksr extends Message<shadowsocksr> {
  /**
   * @generated from field: string server = 1;
   */
  server = "";

  /**
   * @generated from field: string port = 2;
   */
  port = "";

  /**
   * @generated from field: string method = 3;
   */
  method = "";

  /**
   * @generated from field: string password = 4;
   */
  password = "";

  /**
   * @generated from field: string obfs = 5;
   */
  obfs = "";

  /**
   * @generated from field: string obfsparam = 6;
   */
  obfsparam = "";

  /**
   * @generated from field: string protocol = 7;
   */
  protocol = "";

  /**
   * @generated from field: string protoparam = 8;
   */
  protoparam = "";

  constructor(data?: PartialMessage<shadowsocksr>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.shadowsocksr";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "port", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "obfs", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "obfsparam", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "protocol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "protoparam", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): shadowsocksr {
    return new shadowsocksr().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): shadowsocksr {
    return new shadowsocksr().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): shadowsocksr {
    return new shadowsocksr().fromJsonString(jsonString, options);
  }

  static equals(a: shadowsocksr | PlainMessage<shadowsocksr> | undefined, b: shadowsocksr | PlainMessage<shadowsocksr> | undefined): boolean {
    return proto3.util.equals(shadowsocksr, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.http2
 */
export class http2 extends Message<http2> {
  /**
   * @generated from field: int32 concurrency = 1;
   */
  concurrency = 0;

  constructor(data?: PartialMessage<http2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.http2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "concurrency", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): http2 {
    return new http2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): http2 {
    return new http2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): http2 {
    return new http2().fromJsonString(jsonString, options);
  }

  static equals(a: http2 | PlainMessage<http2> | undefined, b: http2 | PlainMessage<http2> | undefined): boolean {
    return proto3.util.equals(http2, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.vmess
 */
export class vmess extends Message<vmess> {
  /**
   * uuid
   *
   * @generated from field: string uuid = 1 [json_name = "id"];
   */
  uuid = "";

  /**
   * alter id
   *
   * @generated from field: string alter_id = 2 [json_name = "aid"];
   */
  alterId = "";

  /**
   * @generated from field: string security = 3;
   */
  security = "";

  constructor(data?: PartialMessage<vmess>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.vmess";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", jsonName: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "alter_id", jsonName: "aid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "security", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): vmess {
    return new vmess().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): vmess {
    return new vmess().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): vmess {
    return new vmess().fromJsonString(jsonString, options);
  }

  static equals(a: vmess | PlainMessage<vmess> | undefined, b: vmess | PlainMessage<vmess> | undefined): boolean {
    return proto3.util.equals(vmess, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.vless
 */
export class vless extends Message<vless> {
  /**
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  constructor(data?: PartialMessage<vless>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.vless";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): vless {
    return new vless().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): vless {
    return new vless().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): vless {
    return new vless().fromJsonString(jsonString, options);
  }

  static equals(a: vless | PlainMessage<vless> | undefined, b: vless | PlainMessage<vless> | undefined): boolean {
    return proto3.util.equals(vless, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.trojan
 */
export class trojan extends Message<trojan> {
  /**
   * @generated from field: string password = 1;
   */
  password = "";

  /**
   * @generated from field: string peer = 2;
   */
  peer = "";

  constructor(data?: PartialMessage<trojan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.trojan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "peer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): trojan {
    return new trojan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): trojan {
    return new trojan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): trojan {
    return new trojan().fromJsonString(jsonString, options);
  }

  static equals(a: trojan | PlainMessage<trojan> | undefined, b: trojan | PlainMessage<trojan> | undefined): boolean {
    return proto3.util.equals(trojan, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.yuubinsya
 */
export class yuubinsya extends Message<yuubinsya> {
  /**
   * @generated from field: string password = 1;
   */
  password = "";

  /**
   * @generated from field: bool tcp_encrypt = 4 [json_name = "tcp_encrypt"];
   */
  tcpEncrypt = false;

  /**
   * @generated from field: bool udp_encrypt = 5 [json_name = "udp_encrypt"];
   */
  udpEncrypt = false;

  /**
   * @generated from field: bool udp_over_stream = 3 [json_name = "udp_over_stream"];
   */
  udpOverStream = false;

  constructor(data?: PartialMessage<yuubinsya>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.yuubinsya";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "tcp_encrypt", jsonName: "tcp_encrypt", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "udp_encrypt", jsonName: "udp_encrypt", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "udp_over_stream", jsonName: "udp_over_stream", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): yuubinsya {
    return new yuubinsya().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): yuubinsya {
    return new yuubinsya().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): yuubinsya {
    return new yuubinsya().fromJsonString(jsonString, options);
  }

  static equals(a: yuubinsya | PlainMessage<yuubinsya> | undefined, b: yuubinsya | PlainMessage<yuubinsya> | undefined): boolean {
    return proto3.util.equals(yuubinsya, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.websocket
 */
export class websocket extends Message<websocket> {
  /**
   * @generated from field: string host = 1;
   */
  host = "";

  /**
   * @generated from field: string path = 2;
   */
  path = "";

  constructor(data?: PartialMessage<websocket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.websocket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): websocket {
    return new websocket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): websocket {
    return new websocket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): websocket {
    return new websocket().fromJsonString(jsonString, options);
  }

  static equals(a: websocket | PlainMessage<websocket> | undefined, b: websocket | PlainMessage<websocket> | undefined): boolean {
    return proto3.util.equals(websocket, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.grpc
 */
export class grpc extends Message<grpc> {
  /**
   * @generated from field: yuhaiin.protocol.tls_config tls = 1;
   */
  tls?: tls_config;

  constructor(data?: PartialMessage<grpc>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.grpc";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tls", kind: "message", T: tls_config },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): grpc {
    return new grpc().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): grpc {
    return new grpc().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): grpc {
    return new grpc().fromJsonString(jsonString, options);
  }

  static equals(a: grpc | PlainMessage<grpc> | undefined, b: grpc | PlainMessage<grpc> | undefined): boolean {
    return proto3.util.equals(grpc, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.quic
 */
export class quic extends Message<quic> {
  /**
   * @generated from field: string host = 2;
   */
  host = "";

  /**
   * @generated from field: yuhaiin.protocol.tls_config tls = 1;
   */
  tls?: tls_config;

  constructor(data?: PartialMessage<quic>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.quic";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "tls", kind: "message", T: tls_config },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): quic {
    return new quic().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): quic {
    return new quic().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): quic {
    return new quic().fromJsonString(jsonString, options);
  }

  static equals(a: quic | PlainMessage<quic> | undefined, b: quic | PlainMessage<quic> | undefined): boolean {
    return proto3.util.equals(quic, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.reality
 */
export class reality extends Message<reality> {
  /**
   * @generated from field: string server_name = 1 [json_name = "server_name"];
   */
  serverName = "";

  /**
   * @generated from field: string public_key = 2 [json_name = "public_key"];
   */
  publicKey = "";

  /**
   * @generated from field: string short_id = 3 [json_name = "short_id"];
   */
  shortId = "";

  /**
   * @generated from field: bool debug = 4;
   */
  debug = false;

  constructor(data?: PartialMessage<reality>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.reality";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server_name", jsonName: "server_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "public_key", jsonName: "public_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "short_id", jsonName: "short_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "debug", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): reality {
    return new reality().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): reality {
    return new reality().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): reality {
    return new reality().fromJsonString(jsonString, options);
  }

  static equals(a: reality | PlainMessage<reality> | undefined, b: reality | PlainMessage<reality> | undefined): boolean {
    return proto3.util.equals(reality, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.obfs_http
 */
export class obfs_http extends Message<obfs_http> {
  /**
   * @generated from field: string host = 1;
   */
  host = "";

  /**
   * @generated from field: string port = 2;
   */
  port = "";

  constructor(data?: PartialMessage<obfs_http>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.obfs_http";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "port", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): obfs_http {
    return new obfs_http().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): obfs_http {
    return new obfs_http().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): obfs_http {
    return new obfs_http().fromJsonString(jsonString, options);
  }

  static equals(a: obfs_http | PlainMessage<obfs_http> | undefined, b: obfs_http | PlainMessage<obfs_http> | undefined): boolean {
    return proto3.util.equals(obfs_http, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.none
 */
export class none extends Message<none> {
  constructor(data?: PartialMessage<none>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.none";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): none {
    return new none().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): none {
    return new none().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): none {
    return new none().fromJsonString(jsonString, options);
  }

  static equals(a: none | PlainMessage<none> | undefined, b: none | PlainMessage<none> | undefined): boolean {
    return proto3.util.equals(none, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.simple
 */
export class simple extends Message<simple> {
  /**
   * @generated from field: string host = 1;
   */
  host = "";

  /**
   * @generated from field: int32 port = 2;
   */
  port = 0;

  /**
   * @generated from field: repeated yuhaiin.protocol.host alternate_host = 5 [json_name = "alternate_host"];
   */
  alternateHost: host[] = [];

  constructor(data?: PartialMessage<simple>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.simple";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "alternate_host", jsonName: "alternate_host", kind: "message", T: host, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): simple {
    return new simple().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): simple {
    return new simple().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): simple {
    return new simple().fromJsonString(jsonString, options);
  }

  static equals(a: simple | PlainMessage<simple> | undefined, b: simple | PlainMessage<simple> | undefined): boolean {
    return proto3.util.equals(simple, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.tls_config
 */
export class tls_config extends Message<tls_config> {
  /**
   * @generated from field: bool enable = 1;
   */
  enable = false;

  /**
   * @generated from field: repeated string server_names = 6 [json_name = "servernames"];
   */
  serverNames: string[] = [];

  /**
   * @generated from field: repeated bytes ca_cert = 3 [json_name = "ca_cert"];
   */
  caCert: Uint8Array[] = [];

  /**
   * @generated from field: bool insecure_skip_verify = 4 [json_name = "insecure_skip_verify"];
   */
  insecureSkipVerify = false;

  /**
   * next_protos ALPN Next Protocol
   * eg: h2, http/1.1
   *
   * @generated from field: repeated string next_protos = 5 [json_name = "next_protos"];
   */
  nextProtos: string[] = [];

  constructor(data?: PartialMessage<tls_config>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.tls_config";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "server_names", jsonName: "servernames", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "ca_cert", jsonName: "ca_cert", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 4, name: "insecure_skip_verify", jsonName: "insecure_skip_verify", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "next_protos", jsonName: "next_protos", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): tls_config {
    return new tls_config().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): tls_config {
    return new tls_config().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): tls_config {
    return new tls_config().fromJsonString(jsonString, options);
  }

  static equals(a: tls_config | PlainMessage<tls_config> | undefined, b: tls_config | PlainMessage<tls_config> | undefined): boolean {
    return proto3.util.equals(tls_config, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.direct
 */
export class direct extends Message<direct> {
  constructor(data?: PartialMessage<direct>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.direct";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): direct {
    return new direct().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): direct {
    return new direct().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): direct {
    return new direct().fromJsonString(jsonString, options);
  }

  static equals(a: direct | PlainMessage<direct> | undefined, b: direct | PlainMessage<direct> | undefined): boolean {
    return proto3.util.equals(direct, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.reject
 */
export class reject extends Message<reject> {
  constructor(data?: PartialMessage<reject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.reject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): reject {
    return new reject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): reject {
    return new reject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): reject {
    return new reject().fromJsonString(jsonString, options);
  }

  static equals(a: reject | PlainMessage<reject> | undefined, b: reject | PlainMessage<reject> | undefined): boolean {
    return proto3.util.equals(reject, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.drop
 */
export class drop extends Message<drop> {
  constructor(data?: PartialMessage<drop>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.drop";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): drop {
    return new drop().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): drop {
    return new drop().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): drop {
    return new drop().fromJsonString(jsonString, options);
  }

  static equals(a: drop | PlainMessage<drop> | undefined, b: drop | PlainMessage<drop> | undefined): boolean {
    return proto3.util.equals(drop, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.host
 */
export class host extends Message<host> {
  /**
   * @generated from field: string host = 1;
   */
  host = "";

  /**
   * @generated from field: int32 port = 2;
   */
  port = 0;

  constructor(data?: PartialMessage<host>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.host";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): host {
    return new host().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): host {
    return new host().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): host {
    return new host().fromJsonString(jsonString, options);
  }

  static equals(a: host | PlainMessage<host> | undefined, b: host | PlainMessage<host> | undefined): boolean {
    return proto3.util.equals(host, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.wireguard_peer_config
 */
export class wireguard_peer_config extends Message<wireguard_peer_config> {
  /**
   * @generated from field: string public_key = 1;
   */
  publicKey = "";

  /**
   * @generated from field: string pre_shared_key = 2;
   */
  preSharedKey = "";

  /**
   * @generated from field: string endpoint = 3;
   */
  endpoint = "";

  /**
   * @generated from field: int32 keep_alive = 4;
   */
  keepAlive = 0;

  /**
   * @generated from field: repeated string allowed_ips = 5;
   */
  allowedIps: string[] = [];

  constructor(data?: PartialMessage<wireguard_peer_config>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.wireguard_peer_config";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "public_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "pre_shared_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "keep_alive", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "allowed_ips", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): wireguard_peer_config {
    return new wireguard_peer_config().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): wireguard_peer_config {
    return new wireguard_peer_config().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): wireguard_peer_config {
    return new wireguard_peer_config().fromJsonString(jsonString, options);
  }

  static equals(a: wireguard_peer_config | PlainMessage<wireguard_peer_config> | undefined, b: wireguard_peer_config | PlainMessage<wireguard_peer_config> | undefined): boolean {
    return proto3.util.equals(wireguard_peer_config, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.wireguard
 */
export class wireguard extends Message<wireguard> {
  /**
   * @generated from field: string secret_key = 1;
   */
  secretKey = "";

  /**
   * @generated from field: repeated string endpoint = 2;
   */
  endpoint: string[] = [];

  /**
   * @generated from field: repeated yuhaiin.protocol.wireguard_peer_config peers = 3;
   */
  peers: wireguard_peer_config[] = [];

  /**
   * @generated from field: int32 mtu = 4;
   */
  mtu = 0;

  /**
   * @generated from field: bytes reserved = 6;
   */
  reserved = new Uint8Array(0);

  /**
   * @generated from field: int32 idle_timeout = 7;
   */
  idleTimeout = 0;

  constructor(data?: PartialMessage<wireguard>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.wireguard";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "secret_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "peers", kind: "message", T: wireguard_peer_config, repeated: true },
    { no: 4, name: "mtu", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "reserved", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "idle_timeout", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): wireguard {
    return new wireguard().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): wireguard {
    return new wireguard().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): wireguard {
    return new wireguard().fromJsonString(jsonString, options);
  }

  static equals(a: wireguard | PlainMessage<wireguard> | undefined, b: wireguard | PlainMessage<wireguard> | undefined): boolean {
    return proto3.util.equals(wireguard, a, b);
  }
}

/**
 * @generated from message yuhaiin.protocol.mux
 */
export class mux extends Message<mux> {
  /**
   * @generated from field: int32 concurrency = 1;
   */
  concurrency = 0;

  constructor(data?: PartialMessage<mux>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "yuhaiin.protocol.mux";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "concurrency", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): mux {
    return new mux().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): mux {
    return new mux().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): mux {
    return new mux().fromJsonString(jsonString, options);
  }

  static equals(a: mux | PlainMessage<mux> | undefined, b: mux | PlainMessage<mux> | undefined): boolean {
    return proto3.util.equals(mux, a, b);
  }
}

